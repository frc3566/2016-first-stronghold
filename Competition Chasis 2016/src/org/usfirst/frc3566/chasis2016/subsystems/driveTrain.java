// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3566.chasis2016.subsystems;


import org.usfirst.frc3566.chasis2016.RobotMap;
import org.usfirst.frc3566.chasis2016.commands.*;
import edu.wpi.first.wpilibj.CANTalon;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;


/**
 *
 */
public class driveTrain extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	
    private final CANTalon cANTalon1 = RobotMap.backLeftMotor;
    private final CANTalon cANTalon2 = RobotMap.backRightMotor;
    private final CANTalon cANTalon3 = RobotMap.frontLeftMotor;
    private final CANTalon cANTalon4 = RobotMap.frontRightMotor;
    private final CANTalon cANTalon5 = RobotMap.frontSteering;
    private final CANTalon cANTalon6 = RobotMap.backSteering;
    boolean reverseIt;
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    	setDefaultCommand(new DriveWithJoysticks());
    }
    
    public void driveIt(double speed){//Motors 1&3 are opposite from 2&4
    	 cANTalon1.set(speed * -1.0);
    	cANTalon2.set(speed * 1.0);
    	  cANTalon3.set(speed * -1.0); 
    	  cANTalon4.set(speed * 1.0);
    }


    public void drivingWithTurningChanges(double speed, double extraslow){
    double	ratio=1;
       	if (extraslow>0) {//right forward
        	cANTalon1.set((speed-(extraslow*ratio)) * -1.0);
     	cANTalon2.set((speed - ratio*extraslow) * 1);
     	  cANTalon3.set((speed) * -1.0); 
     	  cANTalon4.set((speed-(extraslow*ratio)));
       	}else if(extraslow<0) {//left forward
       		cANTalon1.set((speed-(extraslow*ratio))* -1);
       	 	cANTalon2.set((speed) * 1.0);
       	 	  cANTalon3.set((speed-(extraslow*ratio))*-1); 
       	 	  cANTalon4.set((speed) * 1.0);
       	}else if(speed==0 ){
       		cANTalon1.set((speed) * -1.0);
       	 	cANTalon2.set(speed );
       	 	  cANTalon3.set((speed) * -1.0); 
       	 	  cANTalon4.set(speed);
       	}
        }
    
    public void threeWheelDrive (double speed){
    	if (Math.abs(speed)> 0.2){
        	cANTalon1.set(speed*-1);
        	cANTalon2.set(speed* -1 );
        	cANTalon3.set(speed);
        	cANTalon4.set(speed * -1);
    	SmartDashboard.putNumber("backLeftThreeWheel", speed*-1);
    	SmartDashboard.putNumber("backRightThreeWheel", speed*-1);
    	SmartDashboard.putNumber("frontLeftThreeWheel", speed);
    	SmartDashboard.putNumber("frontRightThreeWheel", speed*-1);
    	} 
    }

    public void wheelSteering(double xAxis, boolean reverseIt){
    //Here is some value stuff
    System.out.println("Hi from wheel steering..  xAxis is " + xAxis);
    System.out.println("Hi FRONT Steering pot says ... " + RobotMap.steeringAnalogPotentiometerFRONT.get());
    System.out.println("Hi BACK Steering pot says ... " + RobotMap.steeringAnalogPotentiometerBACK.get());
    
    if(!reverseIt){
    	System.out.println("Hi from wheel steering..  xAxis is " + xAxis);
    	
    	if(xAxis <0 ){
    		if(RobotMap.steeringAnalogPotentiometerFRONT.get() < RobotMap.FRONT_LIMITS_MAX_LEFTT) {
    			cANTalon5.set(xAxis * .5);
    		}
    		if(RobotMap.steeringAnalogPotentiometerBACK.get() > RobotMap.BACK_LIMITS_MAX_LEFT){
    			cANTalon6.set(xAxis*-.5);
    		}
    	}
    	if(xAxis >0 ){
    		if(RobotMap.steeringAnalogPotentiometerFRONT.get() >RobotMap.FRONT_LIMITS_MAX_RIGHT) {
    			cANTalon5.set(xAxis * .5);
    		}
    		if(RobotMap.steeringAnalogPotentiometerBACK.get() <RobotMap.BACK_LIMITS_MAX_RIGHT){
    			cANTalon6.set(xAxis*-.5);
    		}
    	}
    } else {//if reversed
    	if(xAxis >0 ){
    		if(RobotMap.steeringAnalogPotentiometerFRONT.get() < RobotMap.FRONT_LIMITS_MAX_LEFTT) {
    			cANTalon5.set(xAxis * .5);
    		}
    		if(RobotMap.steeringAnalogPotentiometerBACK.get() > RobotMap.BACK_LIMITS_MAX_LEFT){
    			cANTalon6.set(xAxis*-.5);
    		}
    	}
    	if(xAxis <0 ){
    		if(RobotMap.steeringAnalogPotentiometerFRONT.get() >RobotMap.FRONT_LIMITS_MAX_RIGHT) {
    			cANTalon5.set(xAxis * .5);
    		}
    		if(RobotMap.steeringAnalogPotentiometerBACK.get() <RobotMap.BACK_LIMITS_MAX_RIGHT){
    			cANTalon6.set(xAxis*-.5);
    		}
    	
    	}
    }
    	// new limits Front Drive 7.416 12.071
    	// new limits back 6.111 1.515
    }
    
   public void tankDriveRight (double speed){
	   cANTalon1.set(speed*-1);
	  cANTalon3.set(speed* -1);
   }
   public void tankDriveLeft(double speed){
	   cANTalon2.set(speed);
		  cANTalon4.set(speed);
   }
   
  public void StopMotors(){
    //	set d2stop everytime after d2 is not called 
	  cANTalon1.set(0.0);
  	  cANTalon2.set(0.0);
   	  cANTalon3.set(0.0);
      cANTalon4.set(0.0);
    	//call this after d2 equals 0 
    }

    public boolean getReversedState(){
    	return reverseIt;
    }
    
    public void setReversedTrue(){
    	reverseIt=true;
    }
    
    public void setReversedFalse(){
    	reverseIt=false;
    }

    
}

